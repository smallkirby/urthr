//! mkconst: Generate C-style header file that can be used in linker script and assembly code.

pub fn main() !void {
    if (os.argv.len != 1 + 1) {
        log.err("Usage: {s} <output.h>", .{os.argv[0]});
        return error.InvalidArgs;
    }

    const output_path = std.mem.span(os.argv[1]);

    // Open files.
    const output_file = try fs.cwd().createFile(output_path, .{});
    defer output_file.close();
    errdefer {
        fs.cwd().deleteFile(output_path) catch {
            log.err("Failed to delete output file: {s}", .{output_path});
        };
    }

    var wbuffer: [4096]u8 = undefined;
    var writer = output_file.writer(&wbuffer);
    const writer_if = &writer.interface;

    // Put a header comment.
    try putHeaderComment(writer_if);

    // Iterate through decls for physical memory map.
    try writer_if.writeAll(
        \\
        \\// =============================================================
        \\// Physical Memory Map
        \\// =============================================================
        \\
        \\
    );
    inline for (@typeInfo(map).@"struct".decls) |field| {
        const name = field.name;
        const value = @field(map, name);

        try writeItem(value, name, writer_if, "P_");
    }

    // Iterate through decls for virtual memory map.
    try writer_if.writeAll(
        \\
        \\// =============================================================
        \\// Virtual Memory Map
        \\// =============================================================
        \\
        \\
    );
    inline for (@typeInfo(vmemmap).@"struct".decls) |field| {
        const name = field.name;
        const value = @field(vmemmap, name);

        try writeItem(value, name, writer_if, "V_");
    }
}

/// Write a header comment to the output writer.
fn putHeaderComment(writer: *std.io.Writer) !void {
    try writer.print(
        \\//! This file is auto-generated by mkconst.
        \\//!
        \\//! Do not edit this file directly.
        \\//!
        \\//! Board Type: {s}
        \\
        \\
    , .{board_name});
}

/// Write a single constant declaration to the output writer.
fn writeItem(value: anytype, name: []const u8, writer: *std.io.Writer, prefix: []const u8) !void {
    var out_name: [256]u8 = undefined;
    var out_value: [256]u8 = undefined;

    switch (@typeInfo(@TypeOf(value))) {
        .comptime_int => {
            // Name
            const namep = std.ascii.upperString(
                &out_name,
                name,
            );
            // Value
            const valuen = std.fmt.printInt(
                &out_value,
                value,
                16,
                .upper,
                .{},
            );

            try writer.print(
                "#define {s}{s} 0x{s}\n\n",
                .{ prefix, namep, out_value[0..valuen] },
            );
        },

        .@"struct" => {
            switch (@TypeOf(value)) {
                Range => {
                    try writeRangeItem(
                        value,
                        name,
                        writer,
                        prefix,
                    );
                },

                else => return unsupportedType(value),
            }
        },

        .array => |array| {
            switch (array.child) {
                Range => {
                    const ptr: [*]const Range = @ptrCast(&value);
                    for (ptr[0..array.len], 0..) |range, i| {
                        const name_indexed = try std.fmt.bufPrint(
                            &out_name,
                            "{s}_{d}",
                            .{ name, i },
                        );

                        try writeRangeItem(
                            range,
                            name_indexed,
                            writer,
                            prefix,
                        );
                    }
                },

                else => return unsupportedType(value),
            }
        },

        else => return unsupportedType(value),
    }

    try writer.flush();
}

/// Write a Range item to the output writer.
fn writeRangeItem(value: Range, name: []const u8, writer: *std.io.Writer, prefix: []const u8) !void {
    var out_name: [256]u8 = undefined;
    var out_value: [256]u8 = undefined;

    const namep = std.ascii.upperString(
        &out_name,
        name,
    );

    // Start
    const start = std.fmt.printInt(
        &out_value,
        value.start,
        16,
        .upper,
        .{},
    );
    try writer.print(
        "#define {s}{s}_START 0x{s}\n",
        .{ prefix, namep, out_value[0..start] },
    );

    // End
    const end = std.fmt.printInt(
        &out_value,
        value.end,
        16,
        .upper,
        .{},
    );
    try writer.print(
        "#define {s}{s}_END 0x{s}\n",
        .{ prefix, namep, out_value[0..end] },
    );

    // Size
    const size = std.fmt.printInt(
        &out_value,
        value.end - value.start,
        16,
        .upper,
        .{},
    );
    try writer.print(
        "#define {s}{s}_SIZE 0x{s}\n",
        .{ prefix, namep, out_value[0..size] },
    );

    try writer.print("\n", .{});
}

/// Print an error for unsupported type.
fn unsupportedType(value: anytype) void {
    log.err(
        "Unsupported type for constant generation: {s}",
        .{@typeName(@TypeOf(value))},
    );
}

// =============================================================
// Imports
// =============================================================

const std = @import("std");
const log = std.log.scoped(.mkconst);
const fs = std.fs;
const os = std.os;
const board = @import("board").impl;
const board_name = @import("board").description();
const map = board.memmap;
const common = @import("common");
const Range = common.Range;
const urd = @import("urthr");
const vmemmap = urd.mem.vmap;
