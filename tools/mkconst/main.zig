//! mkconst: Generate C-style header file that can be used in linker script and assembly code.

pub fn main() !void {
    if (os.argv.len != 1 + 1) {
        log.err("Usage: {s} <output.h>", .{os.argv[0]});
        return error.InvalidArgs;
    }

    const output_path = std.mem.span(os.argv[1]);

    // Open files.
    const output_file = try fs.cwd().createFile(output_path, .{});
    defer output_file.close();
    errdefer {
        fs.cwd().deleteFile(output_path) catch {
            log.err("Failed to delete output file: {s}", .{output_path});
        };
    }

    var wbuffer: [4096]u8 = undefined;
    var writer = output_file.writer(&wbuffer);
    const writer_if = &writer.interface;

    // Put a header comment.
    try putHeaderComment(writer_if);

    // Iterate through decls in the input Zig file.
    inline for (@typeInfo(map).@"struct".decls) |field| {
        const name = field.name;
        const value = @field(map, name);

        try writeItem(value, name, writer_if);
    }
}

/// Write a header comment to the output writer.
fn putHeaderComment(writer: *std.io.Writer) !void {
    try writer.print(
        \\//! This file is auto-generated by mkconst.
        \\//!
        \\//! Do not edit this file directly.
        \\//!
        \\//! Board Type: {s}
        \\
        \\
    , .{board_name});
}

/// Write a single constant declaration to the output writer.
fn writeItem(value: anytype, name: []const u8, writer: *std.io.Writer) !void {
    var out_name: [256]u8 = undefined;
    var out_value: [256]u8 = undefined;

    switch (@TypeOf(value)) {
        comptime_int => {
            // Name
            const namep = std.ascii.upperString(
                &out_name,
                name,
            );
            // Value
            const valuen = std.fmt.printInt(
                &out_value,
                value,
                16,
                .upper,
                .{},
            );

            try writer.print("#define {s} 0x{s}\n\n", .{ namep, out_value[0..valuen] });
        },

        Range => {
            const namep = std.ascii.upperString(
                &out_name,
                name,
            );

            // Start
            const start = std.fmt.printInt(
                &out_value,
                value.start,
                16,
                .upper,
                .{},
            );
            try writer.print("#define {s}_START 0x{s}\n", .{ namep, out_value[0..start] });

            // End
            const end = std.fmt.printInt(
                &out_value,
                value.end,
                16,
                .upper,
                .{},
            );
            try writer.print("#define {s}_END 0x{s}\n", .{ namep, out_value[0..end] });

            // Size
            const size = std.fmt.printInt(
                &out_value,
                value.end - value.start,
                16,
                .upper,
                .{},
            );
            try writer.print("#define {s}_SIZE 0x{s}\n", .{ namep, out_value[0..size] });

            try writer.print("\n", .{});
        },

        else => {
            log.err("Unsupported type for constant generation: {s}", .{@typeName(@TypeOf(value))});
            return;
        },
    }

    try writer.flush();
}

// =============================================================
// Imports
// =============================================================

const std = @import("std");
const log = std.log.scoped(.mkconst);
const fs = std.fs;
const os = std.os;
const board = @import("board").impl;
const board_name = @import("board").description();
const map = board.memmap;
const common = @import("common");
const Range = common.Range;
